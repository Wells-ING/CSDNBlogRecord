# 一、概述
虚拟机的执行引擎是由软件自行实现的，因为可以不接受物理条件制约地指定指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。
* 在不同的虚拟机实现中，执行引擎在执行字节码的时候，通常会有**解释执行**（通过解释器执行）和**编译执行**（通过即时编译器产生本地代码执行）两种选择，也可能两者兼备，还可能会有同时包含几个级别的即时编译器一起工作的执行引擎。
* 当从外观上看来，所以的Java虚拟机执行引擎输入、输出都是一致的；输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行结果
# 二、运行时栈帧结构
Java虚拟机以方法作为最基本的执行单元，“栈帧”则是用于支持虚拟机进行方法调用和方法执行背后的**数据结构**，它也是虚拟机运行时数据区中的虚拟机栈的栈元素。
* 每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息
* 每一个方法从调用开始至执行结束的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程
* 一个栈帧需要分配多少内存，并不会受到程序运行时变量数据的影响，而仅仅取决于程序源码和具体的虚拟机实现的栈内存布局形式
* 一个线程中的方法调用链可能会很长，以Java程序的角度来看，同一时刻、同一条线程里面，在调用堆栈的所有方法都同时处于执行状态
* 而对于执行引擎来讲，在活动线程中，只能位于栈顶的方法才是在运行的，自由位于栈顶的栈帧才是有效的，其称为“当前栈帧”，与这个栈帧所关联的方法被称为当前方法
## 1、局部变量表
局部变量表是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量
* 在Java程序被编译成class文件时，就在方法的Code属性max_locals数据项中确定了该方法所分配的局部变量表的最大容量。
* 局部变量表的荣耀是以变量槽为最小单位
一个变量槽可以存放一个32位以内的数据类型，Java中占有不超过32位存储空间的数据类型有boolean、byte、char、short、int、float、reference和returnAddress这8种类型
* reference类型表示对一个对象实例的引用，《Java虚拟机规范》既没有说明它的长度，也没有明确指出这种引用应有怎样的结构。但是一般来说，虚拟机实现至少都应当能通过这个引用做到两件事情，一是从根据引用直接或间接地查找到对象在Java堆中的数据存放的起始地址或索引，而是根据引用直接或间接地查询到对象所属数据结构在方法去中存储的数据类型，否则将无法实现《Java语言规范》中定义的语法约定。
* returnAddress类型目前已经很少见了，它是字节码指令jsr、jsr_w和ret服务的，指向了一条字节码指令的地址
对于64位的数据类型，Java虚拟机会以高位补齐为其分配两个连续的变量槽控件。

由于局部变量表是建立在线程堆栈中的，属于线程私有的数据，无论读写两个连续的变量槽是否为原子操作，都不会引起数据竞争和线程安全问题
* Java虚拟机通过索引定位的方式使用局部变量表，索引值的范围是0开始至局部变量表最大的变量槽数量。
如果访问的是32位数据类型的变量，索引N就代表了使用第N个变量槽
如果访问的是64位数据类型的变量，则说明会同时使用第N和N+1两个变量槽
对于两个相邻的共同存放的一个64位数据的两个变量槽，虚拟机不允许采用任何方式单独访问其中的某一个，如果遇到进行这种操作的字节码序列，虚拟机就应该在类加载的校验阶段中抛出异常。
* 当一个方法被调用时，Java虚拟机会使用局部变量表来完成参数值到参数变量列表的传参过程，即实参到形参的传递
  * 如果执行的是实例方法（没有被static修饰的方法），那局部变量表中第0位索引的变量槽模式使用与传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问到这个隐含的参数
  * 其余参数则按照参数表顺序排列，占用从1开始的局部变量槽，参数表分配完毕后，再根据方法体内部定义的不良顺序和作用域分配其余的变量槽
* 局部变量表中的变量槽是可以重用的
    方法体中定义的变量，其作用域并不一定会覆盖整个方法体，如果当前字节码PC计数器的值已经超过了某个变量的作用域，那这个变量对应的变量槽就可以交给其他变量来重用

局部变量槽服用对垃圾收集的影响：
1、影响一：
public static void main(String[] args) {
    byte[] by = new byte[64*1024*1024];
    System.gc();
}
在虚拟机运行参数中添加“-verbose：gc”来看看垃圾手机的结果，发现在System.gc()运行后没有回首掉这64MB的内存
运行结果：
[0.025s][info][gc] Using G1
[0.226s][info][gc] GC(0) Pause Full (System.gc()) 68M->66M(230M) 3.789ms
在运行System.gc()时，变量by还处于作用域之内，虚拟机自然不会回收掉by的内存